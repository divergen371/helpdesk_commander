defmodule HelpdeskCommander.Repo.Migrations.AddTicketConversationsEvents do
  @moduledoc """
  Updates resources based on their most recent snapshots.

  This file was autogenerated with `mix ash_postgres.generate_migrations`
  """

  use Ecto.Migration

  def up do
    create table(:ticket_events, primary_key: false) do
      add :id, :bigserial, null: false, primary_key: true
      add :event_type, :text, null: false
      add :data, :map, null: false, default: %{}

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :ticket_id,
          references(:tickets,
            column: :id,
            name: "ticket_events_ticket_id_fkey",
            type: :bigint,
            prefix: "public"
          ),
          null: false

      add :actor_id,
          references(:users,
            column: :id,
            name: "ticket_events_actor_id_fkey",
            type: :bigint,
            prefix: "public"
          ),
          null: false
    end

    create table(:conversations, primary_key: false) do
      add :id, :bigserial, null: false, primary_key: true
      add :kind, :text, null: false
      add :external_provider, :text
      add :external_ref, :text

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :ticket_id,
          references(:tickets,
            column: :id,
            name: "conversations_ticket_id_fkey",
            type: :bigint,
            prefix: "public"
          ),
          null: false

      add :created_by_id,
          references(:users,
            column: :id,
            name: "conversations_created_by_id_fkey",
            type: :bigint,
            prefix: "public"
          )
    end

    create unique_index(:conversations, [:ticket_id, :kind],
             name: "conversations_unique_ticket_kind_index"
           )

    execute("""
    INSERT INTO conversations (ticket_id, kind, created_by_id, inserted_at)
    SELECT id, 'internal_public', requester_id, inserted_at
    FROM tickets
    ON CONFLICT (ticket_id, kind) DO NOTHING;
    """)

    execute("""
    INSERT INTO conversations (ticket_id, kind, created_by_id, inserted_at)
    SELECT id, 'internal_private', requester_id, inserted_at
    FROM tickets
    ON CONFLICT (ticket_id, kind) DO NOTHING;
    """)

    create table(:conversation_messages, primary_key: false) do
      add :id, :bigserial, null: false, primary_key: true
      add :message_type, :text, null: false, default: "message"
      add :body, :text, null: false
      add :body_format, :text, null: false, default: "plain"
      add :meta, :map, null: false, default: %{}
      add :deleted_at, :utc_datetime_usec

      add :inserted_at, :utc_datetime_usec,
        null: false,
        default: fragment("(now() AT TIME ZONE 'utc')")

      add :conversation_id,
          references(:conversations,
            column: :id,
            name: "conversation_messages_conversation_id_fkey",
            type: :bigint,
            prefix: "public"
          ),
          null: false

      add :sender_id,
          references(:users,
            column: :id,
            name: "conversation_messages_sender_id_fkey",
            type: :bigint,
            prefix: "public"
          ),
          null: false
    end

    execute("""
    INSERT INTO conversation_messages (conversation_id, sender_id, body, message_type, body_format, meta, inserted_at)
    SELECT c.id, tm.sender_id, tm.body, 'message', 'plain', '{}'::jsonb, tm.inserted_at
    FROM ticket_messages tm
    JOIN conversations c ON c.ticket_id = tm.ticket_id AND c.kind = 'internal_public';
    """)

    execute("""
    UPDATE tickets AS t
    SET latest_message_at = data.latest_message_at
    FROM (
      SELECT c.ticket_id, max(cm.inserted_at) AS latest_message_at
      FROM conversation_messages cm
      JOIN conversations c ON c.id = cm.conversation_id
      GROUP BY c.ticket_id
    ) AS data
    WHERE data.ticket_id = t.id
      AND (t.latest_message_at IS NULL OR t.latest_message_at < data.latest_message_at);
    """)

    execute("""
    INSERT INTO ticket_events (ticket_id, actor_id, event_type, data, inserted_at)
    SELECT id, requester_id, 'ticket_created', '{}'::jsonb, inserted_at
    FROM tickets;
    """)

    create index(:ticket_events, [:ticket_id, :id], name: "ticket_events_ticket_id_id_index")

    create index(:conversation_messages, [:conversation_id, :id],
             name: "conversation_messages_conversation_id_id_index"
           )
  end

  def down do
    drop_if_exists index(:conversation_messages, [:conversation_id, :id],
                     name: "conversation_messages_conversation_id_id_index"
                   )

    drop_if_exists index(:ticket_events, [:ticket_id, :id],
                     name: "ticket_events_ticket_id_id_index"
                   )

    drop constraint(:conversation_messages, "conversation_messages_conversation_id_fkey")

    drop constraint(:conversation_messages, "conversation_messages_sender_id_fkey")

    drop table(:conversation_messages)

    drop_if_exists unique_index(:conversations, [:ticket_id, :kind],
                     name: "conversations_unique_ticket_kind_index"
                   )

    drop constraint(:conversations, "conversations_ticket_id_fkey")

    drop constraint(:conversations, "conversations_created_by_id_fkey")

    drop table(:conversations)

    drop constraint(:ticket_events, "ticket_events_ticket_id_fkey")

    drop constraint(:ticket_events, "ticket_events_actor_id_fkey")

    drop table(:ticket_events)
  end
end
