# Helpdesk Commander 要件定義

## 1. 背景・目的
Helpdesk Commander は、社内の「タスク管理」と「ヘルプデスク（問い合わせ/チケット）」を統合し、品質に関わる全員が状況を共有しながら、迅速に一次対応〜解決〜検証〜承認までを完結できるようにする。

本要件定義では、従来の問い合わせ受付/チケット管理に加えて、個別不具合・性能劣化・ミッションクリティカルな障害を含む「障害管理（Incident Management）」を段階的に導入するための要件を定義する。

## 2. スコープ
### 2.1 対象（スコープ内）
- Webフォームからの問い合わせ受付
- 問い合わせからのチケット自動生成
- チケットの状態管理、担当、優先度、SLAの運用
- チケット解決後の「品質確認（検証）」と「最終承認」
- 障害（Incident）への昇格/降格、およびタイムライン管理（段階導入）
- ダッシュボード/レポート（段階導入）

### 2.2 非対象（当面スコープ外）
- 初期段階での監視連携（将来対応）
- チャット連携（将来対応）
- SSO（将来対応）

## 3. 利用者・ロール
### 3.1 基本方針
- 利用者はサポート担当に限定しない。品質に関わる人間は全員が操作できる。
- **顧客（社外）からの障害報告も受け付けるため、社外ユーザーも利用者に含む。**
- **社内ユーザーは全件閲覧可能**とする。
- **社外ユーザーは自社チケットのみ閲覧可能**とし、全体公開は別途承認制とする。
- ただし、以下は管理者またはリーダーのみが実行できる。
  - 検証・承認（Verified/Closed への遷移）
  - 優先度・担当者アサインの変更確定
  - Incident の宣言（昇格）/解除（降格）
- 優先度・担当者アサインの変更入力は誰でも可能だが、**変更の確定は管理者/リーダーのみ**とする。

### 3.2 ロール案（初期）
- 一般ユーザー（Requester/Verifier: 社内/社外）
  - 問い合わせの作成
  - チケットの閲覧（全件）
  - コメント/追加情報提供
  - 検証（品質確認）の実施・結果入力
  - **社外ユーザーは role="customer" を想定する**
- エージェント（Agent）
  - チケット対応、状態更新、担当作業
  - 検証依頼の実施（依頼者/第三者への依頼）
- リーダー/管理者（Leader/Admin）
  - 優先度管理
  - Incident 運用（宣言/解除、SEV設定）
  - 検証結果の承認、クローズ

### 3.3 会社/テナント運用
- **会社の作成は社内のみ**が行う。
- 会社IDは「英字1文字 + ハイフン + 数字6桁」（例: `A-123456`）を利用する。
- 会社IDはDBに平文保存せず、**HMAC-SHA256（secret付き）でハッシュ化**した値のみ保存する。
- 会社IDの表示は不要とし、**会社名を表示する**。

### 3.4 ログイン識別子（best practice）
- 認証用の **login_id（ユーザー名）** と表示用の **display_name（人名）** を分離する。
- login_id は **ASCII（a-z0-9 / - / _）のみ**を許可し、**company内ユニーク**とする。
  - 推奨長: 3..32
- display_name は **Unicode可**（ひらがな/漢字等を許可）とし、UI表示にのみ利用する。
  - 推奨長: 1..100
- ログインは「会社ID + login_id or email + パスワード」で行う。

## 4. 概念モデル（用語・エンティティ）
### 4.1 問い合わせ（Inquiry）
- Webフォームから投稿される入力。
- 投稿後にチケットを自動生成する。

### 4.2 チケット（Ticket）
- 運用の基本単位。問い合わせ・困りごと・質問・不具合・障害候補を統一的に扱う。
- チケットの種別（type）により運用を分岐する。

チケット種別（例）
- question（質問）
- request（依頼）
- bug（個別不具合）
- incident_candidate（障害候補）

### 4.3 障害（Incident）
- サービス影響が大きい事象を扱う「障害管理」用の追加レイヤ。
- Ticket から Incident に昇格して運用する。
- Incident はタイムライン（いつ、何が起き、どう対応し、どう復旧したか）を持つ。

### 4.4 検証（Verification）
- チケットの「対応完了（resolved）」後に実施する品質確認。
- 検証者は一般ユーザー（依頼者）でも可能。
- ただし、最終承認（verified/closed）はリーダー/管理者のみ。

### 4.5 イベントログ（Audit/Event Log）
- 状態変更、担当変更、優先度変更、コメント等の主要操作はイベントとして記録する。
- 監査・ふりかえり・Incidentタイムラインの基盤となる。

### 4.6 チケットチャット（Conversation）
- 受付後のヒアリングや連絡は、チケットに紐づくチャットで行う。
- Ticketのdescriptionに追記していく運用は避け、メッセージを独立した形で永続化する（大量データ・検索・監査・表示性能の観点）。
- 将来の「外部チャット連携（Slack等）」とは別に、まずはアプリ内チャットを提供する。

## 5. 機能要件
### 5.1 受付（Webフォーム）
- Webフォームから問い合わせを作成できる。
- 未ログイン受付は許容しない（問い合わせ作成にはログインが必要）。
- 送信時に最低限の入力（件名/本文等）をバリデーションする。
- 送信後に Ticket を自動生成する。

### 5.1.1 入力バリデーション/サニタイズ（MVP）
- 全入力はサーバ側で必須/長さ/形式を検証する（UI側の検証は補助）。
- 文字列は前後の空白をトリムし、空白のみの入力は無効とする。
- 列挙値（status/type/priority 等）は allowlist で検証する。
- **MVPはプレーンテキストのみ**を許可し、Markdown/HTMLは許可しない。
- 表示時は文脈に応じたエスケープを必須とする（XSS対策）。

最大長（初期値）
- Inquiry: subject 1..200、body 1..10,000
- Ticket: subject 1..200、description 1..10,000
- ConversationMessage: body 1..5,000

将来拡張（Markdown許可時）
- HTMLは無効化し、レンダリング後に allowlist サニタイズを行う。

### 5.2 チケット管理
- チケット一覧：状態、担当、優先度、種別でフィルタ/ソートできる。
- チケット詳細：本文、履歴（イベントログ）、チャット（ヒアリング/連絡）、担当、優先度、SLA情報を表示できる。
- チケット状態管理：定義されたステータスに従って遷移できる。

### 5.2.2 画面設計と画面遷移（初期）
- 画面は「チケット一覧」「新規作成」「詳細」の3画面を基本とする。
- 詳細画面からは一覧へ戻れる導線を用意する（戻る先は一覧）。
- 社外ユーザー（顧客）は「新規作成」「自身が作成したチケット一覧」「自身が作成したチケット詳細」に限定する。
- 社内ユーザーは全チケットの一覧/詳細にアクセスできる。
- **社外ユーザーは他社チケットを閲覧不可**とする。
- ただし **priority=P1 かつ incident_sev=P1 の場合は全体公開候補**とし、**管理者/リーダーの手動承認で公開**できる。

#### 5.2.1 チケットチャット（MVPに含める）
- 自動生成されたチケットに紐づく形で、ヒアリング・連絡用のチャットを提供する。
- チャットは2系統とする。
  - 公開（依頼者も閲覧・投稿できる）
  - 非公開（社内向けメモ。依頼者は閲覧不可）
- チャットは「メッセージの追加」を基本とし、編集は必要最小限（もしくは不可）とする。
- メッセージは独立したデータとして永続化し、一覧表示はページング等でスケールできること。
- チケットの状態変更・重要操作と同様に、チャット投稿も監査可能であること（投稿者・投稿日時）。

推奨ステータス（初期）
- new（受付直後）
- triage（切り分け/情報収集）
- in_progress（対応中）
- waiting（依頼者/他チーム待ち）
- resolved（対応完了）
- verified（検証・承認済）
- closed（クローズ）

### 5.3 検証・承認フロー
- resolved になったチケットは検証フェーズに入る。
- 一般ユーザー（依頼者を含む）は、検証結果を入力できる。
  - 例：再現確認、期待動作確認、手順、結果、確認日時、確認者
- リーダー/管理者のみが、検証結果を確認し最終承認して verified/closed に遷移できる。
- 承認時の承認者・承認日時を記録する。

### 5.4 優先度（Priority）とSLA
- 優先度は Impact（影響）× Urgency（緊急度）から算出する設計を推奨する。
- 優先度の最終確定・変更はリーダー/管理者のみが行える。
- SLAは優先度に紐づく目標時間（一次応答/暫定対応/解決/復旧など）として定義し、監視・可視化する（段階導入）。
- 将来構想: **チケットとタスクの優先度が内容と乖離していないか（齟齬がないか）をチェックする仕組み**を用意する。
  - 設計メモ: [docs/DESIGN_PRIORITY_CHECK.md](DESIGN_PRIORITY_CHECK.md)

優先度（例）
- P1（緊急）
- P2（高）
- P3（中）
- P4（低）

### 5.5 障害管理（Incident）
- 障害とする範囲：個別不具合、性能劣化、ミッションクリティカルな障害を含む。
- チケットから Incident に昇格できる（リーダー/管理者のみ）。
- Incident では以下を扱える。
  - SEV（重大度）
  - 影響範囲
  - タイムライン（調査/暫定対応/復旧/監視/振り返り）
  - 周知用メモ（将来、チャット/ステータスページに展開可能）

### 5.6 タスク管理（README計画に準拠）
- タスクのCRUD
- ステータス（未着手/進行中/完了）
- 優先度（低/中/高）
- 期限
- 担当者

#### 5.6.1 タスク優先度の履歴（追記: 2026-02-01）
- タスクの優先度は状況により変更され得るため、**優先度変更の履歴を保持**する。
- 履歴には少なくとも以下を記録する。
  - 変更前/変更後の優先度
  - 変更者（actor。未ログイン操作は発生しない。システム操作の場合も system user を actor として記録し、null を許容しない）
  - 変更日時
- 将来的にタスクCRUD UIを実装する際、優先度変更は通常の update と分離されたアクション（例: `set_priority`）として扱い、履歴を必ず残す。

#### 5.6.2 system/external actor の扱い（追記: 2026-02-01）
- **監査性のため、イベントの actor は必ず埋める（null禁止）**。
- システム操作は **system user**（例: `system@helpdesk.local` / `name="System"` / `role="system"`）を actor として記録する。
- 外部サービス（例: 監視/チャット連携）からの操作も **必ず actor を持つ**。
  - MVPでは system user に集約し、**外部サービス固有の識別は `data`（event payload）に記録**する。
  - 将来的に必要になれば、`actor_type` + `actor_id` などの拡張で外部サービス主体を明示できる設計へ移行可能とする。

#### 5.6.3 system user の表示名と外部操作の表記（追記: 2026-02-01）
- UI上の actor 表示ルールを以下で統一する。
  - `role="system"` のユーザーは **表示名を常に「System」** とする（本名/メールはUIに出さない）。
  - 外部サービス由来の操作は **「System（source: <service>）」** の形式で表示する。
- 外部サービス由来の操作は、event payload に最低限以下を記録する。
  - `source`（例: `monitoring` / `slack` / `github`）
  - `external_actor_id`（サービス内ユーザーID。無ければ null ではなく `external_actor_name` を必須にする）
  - `external_actor_name`
  - `external_ref`（チケット/通知/スレッドIDなどサービス内参照）

### 5.7 共通
- ユーザー管理
- ダッシュボード（段階導入）
- レポート（段階導入）
- リアルタイム更新（LiveView）

### 5.8 サインアップ/ログイン/ログアウト
- 会社作成は社内のみが実施する。
- 顧客から「作成希望のメールアドレス」を連携してもらい、**仮ユーザー（status=pending）を作成**する。
  - display_name の初期値は email とする（未確定のため暫定表示）。
- 顧客は **会社ID + login_id or email + パスワード**で登録し、**管理者承認後に有効化**される。
- ログアウトはセッション破棄で行う。

## 6. 非機能要件
- 監査性：重要操作はイベントとして追跡可能であること。
- セキュリティ：権限（ロール）により、優先度変更/承認/Incident宣言が制限されること。
- 運用性：チケットとIncidentが同じ体験で追跡でき、将来の連携（監視/チャット/SSO）を阻害しないこと。
- 拡張性：チケット種別やSLAルールの追加・変更が可能であること。

## 7. 段階導入（ロードマップの要件化）
- フェーズ1（MVP）：Webフォーム→Inquiry→Ticket、一覧/詳細、状態更新、イベントログ、チケットチャット（ヒアリング/連絡）
- フェーズ2：認証/権限、優先度管理（リーダー限定）、検証・承認フロー
- フェーズ3：Incident昇格/降格、SEV、タイムライン
- フェーズ4：コメント/添付/通知
- フェーズ5：SLA監視/統計/レポート
- フェーズ6：監視/チャット/SSO連携

## 8. 将来拡張・独自性の高い機能案
- 類似チケット提案（重複検知/既知事象の提示）
- 影響範囲マップ（簡易サービスカタログ）
- 変更相関（デプロイ/PR/DB変更との相関）による原因推定支援

## 9. 懸念点・リスク（設計時に必ず考慮する）
### 9.1 同時編集・状態変更の競合
- 複数人が同一チケットを同時に開いて編集/状態変更するケースがあり、更新競合が発生し得る。
- 競合時に「黙って上書き」すると運用品質が落ちるため、以下のいずれか（または併用）で対処する。
  - 楽観ロック等の競合検知（stale updateの検出）
  - 状態遷移を単一のコマンド/アクションに集約し、遷移の整合性を保証
  - 競合時にUIで再読み込み/差分確認を促す

### 9.2 ヒアリング内容（チャットログ）の保存とスケール
- 受付後のヒアリングをチャット中心で進める場合、TicketやTaskのdescriptionに追記していく方式では肥大化しやすく、検索/表示/監査/将来連携の面で厳しくなる。
- チャットログはメッセージを独立したデータとして保存し、以下を満たす必要がある。
  - 追記中心（append-only）で保存できる
  - 表示はページング等でスケールできる
  - 必要に応じて要約（サマリ）を別フィールドとして保持できる拡張余地がある

### 9.3 LiveView採用に伴う懸念（限界）と回避策
- 一部のUI要件（超リッチなクライアント操作、JSライブラリがDOMを支配するコンポーネント、複雑なクライアント側状態管理）では LiveView が不利になり得る。
- 特に本プロダクトでは、チケット詳細（公開/非公開チャット + リアルタイム更新）がUI/負荷の集中点になり得る。

回避策（設計上の要件）
- LiveViewに巨大な状態を持たせない（全件をassignしない）。チャット/イベント/履歴はページング前提とする。
- コレクションは LiveView streams を基本とし、差分更新を最小化する。
- DOMを強く制御するJS部品は `phx-update="ignore"` + Hook で隔離し、LiveViewの差分更新と衝突させない。
- ビジネスロジックはAsh Resource（ドメイン層）に集約し、UI層にロジックを持ち込まない。

移行の判断基準（React等のSPA導入を検討する条件）
- 主要画面で Hook/ignore 依存が増え、「実質SPA」になって保守性が落ちた。
- チャット/一覧などで、サーバ側コスト（メモリ/CPU/接続数）が許容できないことが計測で判明した。
- オフライン対応や高度なクライアント側状態管理が必須になった。

移行を容易にするための要件（逃げ道）
- 将来的に UI を差し替えられるよう、バックエンドはAPI化可能な設計を保つ（Ashの利用を前提に、必要に応じてJSON API等を追加できること）。

UI検討メモ（追記）
- UI ライブラリとして **Corex** の導入を検討する（適用範囲・導入コスト・LiveViewとの相性を評価）。
