# 関連チケットとグラフ可視化（設計メモ）

## 結論（運用方針）
- **verified / closed は終端**。再変更しない。
- 再発や誤クローズ時は **新しいチケットを起票**し、元チケットと **関連付け**る。
- 関連付けはまず **軽量なリンク（エッジ）** で開始し、将来グラフ可視化へ拡張する。

## 関連チケット（最小構成）
### 目的
- 再発や誤クローズ時のトレーサビリティを確保する。
- チケット間の依存/重複/再発を整理する。

### データモデル（最小）
- `ticket_links` テーブル（エッジ）で **関係タイプ** を保持する。
- 例: `reopened_from` / `related` / `duplicate_of` / `blocks` / `blocked_by`

### UI（初期）
- チケット詳細に「関連チケット」リストを表示
- 関係タイプ・公開ID・件名・状態・優先度を表示
- 後から「グラフ表示」に拡張可能な構造を維持

## 再トリアージについて
- **triage は初期分類**のため、完了後に戻すのは通常は不要。
- 再発時は「**新規チケット起票 + reopened_from**」で扱う方が履歴が明確。
- ただし運用上必要なら、`resolved -> waiting/in_progress` の再オープンで十分。
- triage への戻しは **運用上の混乱を招きやすい**ため基本は非推奨。

## グラフ可視化（将来拡張）
### ねらい
- 障害の波及・依存関係・再発パターンを可視化。
- Incident タイムラインと併せて分析可能にする。

### 段階的導入
1. **関連チケット一覧**（最小）
2. **簡易グラフ**（重要チケットのみ）
3. **Incident中心グラフ**（relation_types を重み付きエッジ化）

### 実装上の注意
- まずは **エッジ数を制限**して表示を簡潔にする。
- “全部を繋げる” よりも **用途に合わせたフィルタ**が重要。
- 将来的に「依存度」や「関係強度」を **重み** として扱うと分析に役立つ。

## グラフ可視化（PoC 設計）
### 表現ルール
- **再起票**は強関係（強調色・強めの表現）。
- **依存**は単方向/双方向を **2本のエッジ** で表現。
- **関係強度**はエッジ太さではなく、**ホバー時にスコア表示**（混雑回避）。
- ノードクリック/ホバー時に **隣接エッジ/ノードを強調**。

### 障害間関係の表現ルール（推奨）
- **関係タイプは色を固定**（再起票/再発=赤系、依存=青系、関連=グレー、重複=紫系）。
- **方向性は必ず矢印**で表現（原因→結果 / 依存→依存先）。
- **強さは数値をホバーで表示**し、線は細め固定で混雑を回避。
- **クラスタは影響領域**（サービス/機能/顧客影響範囲）でまとめる。
- **時系列はタイムラインで補完**し、グラフは関係性に集中。
- **不確実性は線種/透明度**で区別（推定関係は点線など）。
- **重要度はノードサイズ**で表現（影響度/継続時間/再発回数など）。

## 障害関連ファイルのサジェスト（設計メモ）
### 目的
- 障害の事象説明を手がかりに、**リポジトリ全体から関連しそうなコード/設定を提示**する。
- 関連チケット/グラフと合わせて、原因調査の初動を高速化する。

### 対象範囲
- **リポジトリ全体**を探索対象とする。

### 根拠（スコアリングの主軸）
- **Gitログ/コミット履歴**を主要シグナルとして重み付け。
- ログだけで取りこぼしを避けるため、**コード/設定のインデックス化**も併用して補完する。
  - 例: ファイル内語彙、パス構成、コンポーネント名などを軽量インデックス化

### 出力/導線
- **チケット詳細に、社内ユーザーのみ表示される別ページへのリンク/ボタン**を設置。
- 別ページで候補ファイル一覧・根拠（ログ一致/インデックス一致/変更履歴）を表示。

### 段階的アプローチ
#### 段階1: Git log + grep（RAG不要）
- チケットの事象説明からキーワードを抽出し、`git log` / `grep` でリポジトリを走査。
- コミットメッセージ・変更ファイル・差分内のキーワード一致でスコアリング。
- **今すぐ実装可能**。追加ライブラリ不要。

#### 段階2: コードチャンクの embedding + ベクトル検索（RAG導入）
- ソースコード/設定ファイルをセマンティックなチャンクに分割し、embedding を生成。
- チケットの事象説明を embedding 化し、ベクトル類似度検索で関連チャンクを取得。
- キーワード一致では拾えない **意味的な関連** を捕捉できる。
- Elixir 側で embedding 生成 API を呼び出し、ベクトル DB（pgvector 等）に格納。

#### 段階3: エージェント走査 + 依存グラフ検証
- 段階2の結果を起点に、ファイル間の依存関係（import/use/呼び出し）を辿って影響範囲を拡張。
- 候補に対して検証スクリプト（grep/AST解析）を実行し、根拠の確度を上げる。
- 将来的に LLM エージェントによる自動推論も視野に入れる。

### 先行ツールの手法（参考）
- **CodeRabbit**: セマンティックインデックス（関数/クラス/テスト/過去PR単位）+ Codegraph（依存グラフ走査）+ サンドボックス内 verification agent。RAG + 依存グラフ + エージェント検証の3層構成。
- **Cursor**: Merkle tree でファイル変更を検知し、チャンク分割 → embedding → Turbopuffer（ベクトルDB）で nearest-neighbor 検索。Git 履歴もインデックス化。典型的な RAG アーキテクチャ。
- **Antigravity（Google）**: ランタイムトレース（HTTP/DB/キュー）+ tool-using AI のループ（ログ→コード→推論→再検索）+ Chrome 拡張による視覚分析。静的インデックスより動的実行に重心。

### レイアウト方針
- **サーバー固定レイアウト**（安定した視認性）。
- **関連はクラスタ化**し、Obsidianのノート関係グラフを参考にアプリ向けに最適化。

### 技術方針
- 描画は **Sigma.js**（ズーム/パン/ホバー強調はフロントで実装）。
- バックエンドは **意味づけ済みグラフ（ノード/エッジ/座標/スコア）** を生成。
- 現時点では **Elixir側の追加依存は不要**（自前ロジックで対応）。
- ただし **計算負荷/アルゴリズム要件が増えた場合はグラフ/レイアウト系ライブラリ導入を検討**する。
